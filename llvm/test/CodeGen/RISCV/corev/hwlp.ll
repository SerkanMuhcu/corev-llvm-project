; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O2 -mtriple=riscv32 -mattr=+xcorevhwlp < %s \
; RUN:   | FileCheck %s

@var = global i32 0

define void @hwlp(i32 %a) {
; CHECK-LABEL: hwlp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cv.count 0, a0
; CHECK-NEXT:    cv.starti 0, .LBB0_1
; CHECK-NEXT:    cv.endi 0, .Ltmp0
; CHECK-NEXT:    lui a0, %hi(var)
; CHECK-NEXT:  .LBB0_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [%a, %entry], [%j, %loop]
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %loop, label %exit
exit:
  ret void
}

define void @hwlpimm() {
; CHECK-LABEL: hwlpimm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cv.counti 0, 42
; CHECK-NEXT:    cv.starti 0, .LBB1_1
; CHECK-NEXT:    cv.endi 0, .Ltmp1
; CHECK-NEXT:    lui a0, %hi(var)
; CHECK-NEXT:  .LBB1_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [42, %entry], [%j, %loop]
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %loop, label %exit
exit:
  ret void
}

define void @nested_hwlp(i32 %a) {
; CHECK-LABEL: nested_hwlp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cv.count 1, a0
; CHECK-NEXT:    cv.starti 1, .LBB2_1
; CHECK-NEXT:    cv.endi 1, .Ltmp3
; CHECK-NEXT:    lui a1, %hi(var)
; CHECK-NEXT:  .LBB2_1: # %loop
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB2_2 Depth 2
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    cv.setup 0, a0, .Ltmp2
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  .LBB2_2: # %inner
; CHECK-NEXT:    # Parent Loop BB2_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:    nop
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    nop
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.3: # %latch
; CHECK-NEXT:    # in Loop: Header=BB2_1 Depth=1
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.4: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [%a, %entry], [%i_dec, %latch]
  %i_dec = sub i32 %i, 1
  %cmpi = icmp ne i32 %i_dec, 0
  br label %inner
inner:
  %j = phi i32 [%a, %loop], [%j_dec, %inner]
  store volatile i32 0, i32* @var
  %j_dec = sub i32 %j, 1
  %cmpj = icmp ne i32 %j_dec, 0
  br i1 %cmpj, label %inner, label %latch
latch:
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  br i1 %cmpi, label %loop, label %exit
exit:
  ret void
}

define void @two_nested_hwlps(i32 %a) {
; CHECK-LABEL: two_nested_hwlps:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cv.count 1, a0
; CHECK-NEXT:    cv.starti 1, .LBB3_1
; CHECK-NEXT:    cv.endi 1, .Ltmp6
; CHECK-NEXT:    lui a1, %hi(var)
; CHECK-NEXT:  .LBB3_1: # %loop
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB3_2 Depth 2
; CHECK-NEXT:    # Child Loop BB3_4 Depth 2
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    cv.setup 0, a0, .Ltmp4
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  .LBB3_2: # %inner1
; CHECK-NEXT:    # Parent Loop BB3_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:    nop
; CHECK-NEXT:  .Ltmp4:
; CHECK-NEXT:    nop
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.3: # %inner2.preheader
; CHECK-NEXT:    # in Loop: Header=BB3_1 Depth=1
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    cv.setup 0, a0, .Ltmp5
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  .LBB3_4: # %inner2
; CHECK-NEXT:    # Parent Loop BB3_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:    nop
; CHECK-NEXT:  .Ltmp5:
; CHECK-NEXT:    nop
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.5: # %latch
; CHECK-NEXT:    # in Loop: Header=BB3_1 Depth=1
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:  .Ltmp6:
; CHECK-NEXT:    sw zero, %lo(var)(a1)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.6: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [%a, %entry], [%i_dec, %latch]
  %i_dec = sub i32 %i, 1
  %cmpi = icmp ne i32 %i_dec, 0
  br label %inner1
inner1:
  %j = phi i32 [%a, %loop], [%j_dec, %inner1]
  store volatile i32 0, i32* @var
  %j_dec = sub i32 %j, 1
  %cmpj = icmp ne i32 %j_dec, 0
  br i1 %cmpj, label %inner1, label %inner2
inner2:
  %k = phi i32 [%a, %inner1], [%k_dec, %inner2]
  store volatile i32 0, i32* @var
  %k_dec = sub i32 %k, 1
  %cmpk = icmp ne i32 %k_dec, 0
  br i1 %cmpk, label %inner2, label %latch
latch:
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  br i1 %cmpi, label %loop, label %exit
exit:
  ret void
}

define void @loop_with_call(i32 %a) {
; CHECK-LABEL: loop_with_call:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sw ra, 12(sp)
; CHECK-NEXT:    sw s0, 8(sp)
; CHECK-NEXT:    sw s1, 4(sp)
; CHECK-NEXT:    .cfi_offset ra, -4
; CHECK-NEXT:    .cfi_offset s0, -8
; CHECK-NEXT:    .cfi_offset s1, -12
; CHECK-NEXT:    mv s0, a0
; CHECK-NEXT:    lui s1, %hi(var)
; CHECK-NEXT:  .LBB4_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw zero, %lo(var)(s1)
; CHECK-NEXT:    sw zero, %lo(var)(s1)
; CHECK-NEXT:    sw zero, %lo(var)(s1)
; CHECK-NEXT:    addi a0, zero, 42
; CHECK-NEXT:    call hwlp
; CHECK-NEXT:    addi s0, s0, -1
; CHECK-NEXT:    bnez s0, .LBB4_1
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    lw s1, 4(sp)
; CHECK-NEXT:    lw s0, 8(sp)
; CHECK-NEXT:    lw ra, 12(sp)
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [%a, %entry], [%j, %loop]
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  call void @hwlp(i32 42)
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %loop, label %exit
exit:
  ret void
}

define void @guarded_hwlp(i32 %a) {
; CHECK-LABEL: guarded_hwlp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    beqz a0, .LBB5_3
; CHECK-NEXT:  # %bb.1: # %loop.preheader
; CHECK-NEXT:    cv.count 0, a0
; CHECK-NEXT:    cv.starti 0, .LBB5_2
; CHECK-NEXT:    cv.endi 0, .Ltmp7
; CHECK-NEXT:    lui a0, %hi(var)
; CHECK-NEXT:  .LBB5_2: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:  .Ltmp7:
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  .LBB5_3: # %exit
; CHECK-NEXT:    ret
entry:
  %guard = icmp ne i32 %a, 0
  br i1 %guard, label %loop, label %exit
loop:
  %i = phi i32 [%a, %entry], [%j, %loop]
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %loop, label %exit
exit:
  ret void
}

define void @loop_with_nonlinear_cfg(i32 %a, i1 %b) {
; CHECK-LABEL: loop_with_nonlinear_cfg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a1, a1, 1
; CHECK-NEXT:    lui a2, %hi(var)
; CHECK-NEXT:    j .LBB6_2
; CHECK-NEXT:  .LBB6_1: # %f
; CHECK-NEXT:    # in Loop: Header=BB6_2 Depth=1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    beqz a0, .LBB6_4
; CHECK-NEXT:  .LBB6_2: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    beqz a1, .LBB6_1
; CHECK-NEXT:  # %bb.3: # %t
; CHECK-NEXT:    # in Loop: Header=BB6_2 Depth=1
; CHECK-NEXT:    sw zero, %lo(var)(a2)
; CHECK-NEXT:    j .LBB6_1
; CHECK-NEXT:  .LBB6_4: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %i = phi i32 [%a, %entry], [%j, %f]
  br i1 %b, label %t, label %f
t:
  store volatile i32 0, i32* @var
  br label %f
f:
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %loop, label %exit
exit:
  ret void
}

define void @hwlp_two_blocks(i32 %a) {
; CHECK-LABEL: hwlp_two_blocks:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cv.count 0, a0
; CHECK-NEXT:    cv.starti 0, .LBB7_1
; CHECK-NEXT:    cv.endi 0, .Ltmp8
; CHECK-NEXT:    lui a0, %hi(var)
; CHECK-NEXT:  .LBB7_1: # %header
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:  .Ltmp8:
; CHECK-NEXT:    sw zero, %lo(var)(a0)
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.2: # %latch
; CHECK-NEXT:    # in Loop: Header=BB7_1 Depth=1
; CHECK-NEXT:    .option push
; CHECK-NEXT:    .option norvc
; CHECK-NEXT:    .option pop
; CHECK-NEXT:  # %bb.3: # %exit
; CHECK-NEXT:    ret
entry:
  br label %header
latch:
  %j = sub i32 %i, 1
  %cmp = icmp ne i32 %j, 0
  br i1 %cmp, label %header, label %exit
header:
  %i = phi i32 [%a, %entry], [%j, %latch]
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  store volatile i32 0, i32* @var
  br label %latch
exit:
  ret void
}
